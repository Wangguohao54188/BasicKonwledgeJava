### Java语言的三大特性？

继承、封装、多态

**封装**是指将对象的属性私有化，提供一些可以访问属性的方法，我们可以通过访问这些方法得到对象的属性；

**继承**是指某新类继承已经存在的类，该新类拥有被继承类的所有的属性和方法，并且新类可以根据自己的情况拓展属性和方法。

```
1.子类拥有父类对象的所有属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问的，只是拥有。
2.子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
3.子类可以用自己的方式实现父类的方法。
```

注意：Java不支持多继承。

多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同的操作。

java中有两种方式可以实现多态：继承（多个子类对同一个方法进行重写）和接口（实现接口并夫覆盖接口中的同一个方法。）

### 重载和重写的区别？

重载是发生在同一个类中，具有相同的方法名，但是有不同的参数，参数的个数不同，参数的位置不一样，这就是重载常见的就比如构造方法（有参构造无参构造）。

重写发生在当子类继承父类的时候，对父类中的一些方法根据自己的需求进行重写操作。

### 接口和抽象类的区别？

接口和抽象类是支持抽象类定义的两种机制。

接口是公开的，不能有私有的方法和变量；

接口的所有的方法都没有方法体，通过关键字interface实现。

抽象类是可以有私有方法和私有变量的，通过把类或者类中的方法声明为abstract来表示一个类是抽象类，被声明为抽象的方法不能包含方法体；

子类实现方法必须含有相同的或者更低的访问级别（PUBLIC--PROTECTED--PRIVATE）

抽象类的子类为父类中所有抽象方法的具体实现，否则也是抽象类。

**相同点**

1.都不能被实例化；

2.接口的实现类或抽象类的子类都只有实现类接口或抽象类的方法后才能实例化 。

**不同点**

接口只有定义，不能有方法的实现，但是java1.8可以定义default方法体，而抽象类可以有定义和实现，方法可以在抽象类中实现。

实现接口的关键字是implemments继承抽象类的关键字是extends一个类可以实现多个接口，但是一个类只能继承一个抽象类。所以使用接口可以间接的实现多重继承。

接口强调特定功能的实现，而抽象类强调的是所属关系。

接口方法默认的修饰符是public抽象方法可以有public、protected、default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰）

接口被用于常用的功能，便于日后的维护和添加删除，而抽象类更倾向于充当公共类的角色，

从设计层面上讲，抽象类是对类的抽象，是一种模板设计，而接口是对行为的规范， 是一种行为规范。

### java的内部类说一下

一共有四种：  静态内部类、局部内部类、匿名内部类和成员内部类

静态内部类：常见的main函数就是静态内部类，调用静态内部类通过"外部类.静态内部类"

局部内部类：定义在方法中的类叫做局部内部类；

匿名内部类：是指继承一个父类或者实现一个接口的方式直接定义并使用的类，匿名内部类没有class关键字，因为匿名内部类直接使用new生成一个对象

### 说一下final关键字的作用

final关键字可以修饰类、方法和属性。

当final修饰类的时候，表明这个类不能被继承。final类中的所有成员方法都会被隐式的指定为final方法。

当final修饰方法的时候，表明这个方法不能够被重写。

当final修饰属性的时候，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。

### 说一下String、Stringbuffer、StringBuilder的区别

String类中使用final关键字修饰字符数组来保存字符串。private final char value[],所以String对象是不可变的。

StringBuiler与StringBuffer都继承自AbstractStringBuiler类。在AbstractStringBuiler中也是使用字符数组保存字符串char[]value   但是没有用final关键字修饰，所以这两种对象都是可变的。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以说是线程安全的。StringBuiler并没有对方法进行加同步锁，所以是非线程安全的。

总结：

操作少量的数据：适用String；

单线程操作字符串缓冲区下操作大量数据：适用StringBuiler；

多线程操作字符串缓冲区下操作大量数据：适用StringBuffer；

### 说一下Java中的==和equals的区别

==：它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象（基本数据类型==比较的是值，引用类型==比较的是内存地址）

equals：

​	情况1：类没有重写equals()方法。则通过equals()方法比较该类的两个对象时，等价于通过==比较这两个对象。

情况2：类重写了equals()方法。一般，我们都重写equals()方法来比较两个对象的内容是否相等；

若他们的内容相等，则返回true（即，认为这两个对象相等）

### java访问修饰符有哪些？都有什么区别？

java的修饰符有public protected private

1.public:public 表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用

2.private：private表示私有，私有的意思就是除了class自己之外，任何人都不可以直接使用，私有财产不可侵犯，即便是子女朋友都不可以使用。

3.protected：protected对于子女，朋友来说就是public的，可以自由使用，没有任何限制，而对于其他的外部class，protected就变成了private

如何获取private修饰的变量

private通过反射获取，可以设置setAccessable为true实现

### java中的异常体系

Java中的异常主要分为Error和Exception

Error指Java程序运行错误，如果程序启动时出现Error，则启动失败；如果程序运行时出现Error，则系统会退出程序；出现Error是系统的内部错误或资源耗尽，Error不能在程序运行过程中动态处理，一旦出现Error，系统能做的只有记录错误的原因和安全终止。

Exception指Java程序运行异常，在运行中的程序发生了程序员不期望发生的事情，可以被Java异常处理机制处理。Exception也是程序开发中异常处理的核心，可分为RuntimeException（运行时异常）和CheckedException(检查异常)

![](F:%5C%E5%9B%BE%E7%89%87%5Cb21c74be-f3f4-47e3-bb5f-e7e0c959c9bc.png)



RuntimeException（运行时异常）：指在Java虚拟机**正常运行期间抛出的异常**，RuntimeException可以被捕获并处理，如果出现此情况，我们需要抛出异常或者捕获并处理异常。常见的有NullPointerException、ClassCastException、ArrayIndexOutOfBoundsException等

CheckedException（检查异常）：指在**编译阶段Java编译器检查**CheckedException异常，并强制程序捕获和处理此类异常，要求程序在可能出现异常的地方通过try catch语句块捕获异常并处理异常。常见的有由于I/O错误导致的IOException、SQLException、ClassNotFoundException等。该类异常通常由于**打开错误的文件、SQL语法错误、类不存等引起**。



### 异常的处理方式？

回答：异常处理方式有**抛出异常**和**使用try catch语句块**捕获异常两种方式。

（1）**抛出异常**：遇到异常时**不进行具体的处理**，直接将异常抛给调用者，让调用者自己根据情况处理。抛出异常的三种形式：throws、throw和系统自动抛出异常。其中throws作用在方法上，用于定义方法可能抛出的异常；throw作用在方法内，表示明确抛出一个异常。

（2）**使用try catch捕获并处理异常**：使用费try catch 捕获异常能够有针对性的处理每种可能出现的异常，并在捕获到异常后根据不同的情况做不同的处理。其使用过程比较简单：用try catch语句块将可能出现异常的代码包起来即可。

### Java中的深拷贝和浅拷贝说一下？

深拷贝和浅拷贝都是对象拷贝。

浅拷贝：按位拷贝对象，它会创建一个**新对象**，这个对象有着原始对象属性值的一份精确拷贝。如果属性是**基本类型**，拷贝的就是基本类型的值；如果属性是**内存地址**（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会**影响**到另一个对象。（浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。）

![](F:%5C%E5%9B%BE%E7%89%87%5C040BD8C8F2FD40DA858994334E0F0198.png)





上图： 两个引用`student1`和`student2`指向不同的两个对象，但是两个引用`student1`和`student2`中的两个`teacher`**引用指向的是同一个对象**，所以说明是`浅拷贝`。



深拷贝：在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。（深拷贝把要复制的对象所引用的对象都复制了一遍。）

![](F:%5C%E5%9B%BE%E7%89%87%5Ce1e8d6eb-b78c-41f4-9422-4eb782236412.png)

上图：两个引用`student1`和`student2`指向不同的两个对象，两个引用`student1`和`student2`中的两个`teacher`引用指向的是两个对象，但对`teacher`对象的修改只能影响`student1`对象,所以说是`深拷贝`。



### 追问：浅拷贝与深拷贝的特点是什么？

 **浅拷贝特点**

(1) 对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个。
(2) 对于引用类型，比如数组或者类对象，因为引用类型是引用传递，所以浅拷贝只是把内存地址赋值给了成员变量，它们指向了同一内存空间。改变其中一个，会对另外一个也产生影响。

 **深拷贝特点**

(1) 对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个（和浅拷贝一样）。
(2) 对于引用类型，比如数组或者类对象，深拷贝会新建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。改变其中一个，不会对另外一个也产生影响。
(3) 对于有多层对象的，每个对象都需要实现 `Cloneable` 并重写 `clone()` 方法，进而实现了对象的串行层层拷贝。
(4) 深拷贝相比于浅拷贝速度较慢并且花销较大。

### 重载（overload）和重写（override）的区别：

 重载就是同一个类中，有多个方法名相同，但参数列表不同（包括参数个数和参数类型），与返回值无关，与权限修饰符也无关。调用重载的方法时通过传递给它们不同的参数个数和参数类型来决定具体使用哪个方法，这叫多态。 重写就是子类重写基类的方法，方法名，参数列表和返回值都必须相同，否则就不是重写而是重载。权限修饰符不能小于被重写方法的修饰符。重写方法不能抛出新的异常或者是比被重写方法声明更加宽泛的检查型异常。